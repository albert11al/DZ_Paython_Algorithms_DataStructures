##1. Реализовать структуру данных стэк, который за О(1) выдает минимум в стэке:
#Разработайте стек, который поддерживает push, pop, top и извлечение минимального элемента за постоянное время.
#Реализуйте класс MinStack:

#-MinStack() инициализирует объект стека.
#-void push(int val) помещает элемент val в стек.
#-void pop() удаляет элемент на вершине стека.
#-int top() получает верхний элемент стека.
#-int getMin() извлекает минимальный элемент в стеке.

#Пример 1:
#Вход
#["MinStack","push","push","push","getMin","pop","top","getMin"]
#[[],[-2],[0],[-3],[],[],[],[]]
#Выход
#[null,null,null,null,-3,null,0,-2]

# Допустим у нас два СТЭКа.1ый СТЭК сообшает значения которые добовляем.
# 2ой СТЭК сообшает мин. значения которые добавили в 1ый СТЭК. Например:
# push(-2) запишется в СТЭК1 и СТЭК2 т.к. единственное мин. значение.
# push(0) запишется в СТЭК1, а в СТЭК2 сравниваем значения которое добавили push(0) и текушим мин т.е. с -2. Таким образом в СТЭК2 запишется снова -2.
# push(-3) запишется в СТЭК1, а в СТЭК2 сравниваем значения которое добавили push(-3) и текушим мин т.е. с -2. Таким образом в СТЭК2 запишется -3.
#           push -> [-2,0,-3].   min -> [-2,-2,-3]
# чтобы определить самый минимум getMin() мы извлечем вврехушку(последний элемент) СТЭК2
class MinStack(object):

    def __init__(self):
        # Запишем два СТЭКа типа множества
        self.stack1 = []
        self.stack2_min = []

    def push(self, val):
        # СТЭК1 будем всегда добовлять входное значение val
        self.stack1.append(val)
        # СТЭК2 необходимо условие: если stack2_min нет, т.е. пустой то добовляем входное мин. значение val
        if not self.stack2_min:
            self.stack2_min.append(val)
        # иначи если присуствует значение в stack2_min то сравниваем последний записанный элемент СТЭК2
        # с входным значением val, если val< то добовляем входное значение val
        elif val < self.stack2_min[-1]:
            self.stack2_min.append(val)
        # иначи т.е. обратном случаи если val> stack2_min то в stack2_min добовляем значения stack2_min[-1]
        else:
            self.stack2_min.append(self.stack2_min[-1])
# оставил решение того, что сам додумался был вариант такой обновить: val = min(val, self.stack2_min[-1] if self.minStack else val)
# премушества с обновлением val в 14 мс

    def pop(self):
        # возврашать нам ничего не нужно. все, что не обходимой это выйти из СТЭК1 и СТЭК2
        self.stack1.pop()
        self.stack2_min.pop()

    def top(self):
        return self.stack1[-1]

    def getMin(self):
        return self.stack2_min[-1]


