'''№1319
Имеется n компьютеров, пронумерованных от 0 до n - 1, соединенных кабельными соединениями Ethernet,
    образующими сеть, где соединения[i] = [ai, bi] представляют собой соединение между компьютерами ai и bi.
    Любой компьютер может связаться с любым другим компьютером прямо или косвенно через сеть.
Вам даются начальные компьютерные сетевые подключения.
    Вы можете извлечь определенные кабели между двумя напрямую подключенными компьютерами
    и поместить их между любой парой отключенных компьютеров, чтобы сделать их напрямую подключенными.
Верните минимальное количество раз, которое вам нужно сделать, чтобы все компьютеры были подключены.
    Если это невозможно, вернуть -1.'''

class Solution(object):
    def makeConnected(self, n, connections):
        # это невозможно если  количесво ребер меньше узла - 1: connections < (n - 1)
        # т.е. если длина заднного списка ребер меньше заданного количества узла - 1, то решения нет возврашаем -1
        if len(connections) < (n - 1):
            return -1
        # противном случаи нужно посчитать количество компонентов
        # и количество ллишних ребр
        data = list(range(n)) # список номеров ПК в диапазоне от 0 до n, где n - Количество ПК

        def find(i): # ф-ия для поиска родителя в каждом компоненте(кол-во не подключенных ПК)
            if data[i] != i:
                data[i] = find(data[i])
            return data[i]

        def union(i,j):
            data[data[i]] = data[j] # один родиттель из списка номеров ПК, прямой родитель другого

        for u, v in connections:#пройдемся по тем связям, которые нам дано
            pu, pv = find(u), find(v) # делаем поиск узлов u и v
            if pu != pv:# и проверяем отличаются ли узлы друг от друга,
                # чтобы не было несколько ребр между узлами, если узлы разные то их объединяем
                union(u, v)

        count = 0
        for b in range(n):
            if b == find(b):
                count += 1
        return count - 1


