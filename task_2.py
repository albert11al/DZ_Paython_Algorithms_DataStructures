#Написать код для задачи: "Обработка сетевых пакетов".
# условие здесь:https://stepik.org/media/attachments/lesson/41233/statements.pdf

from collections import deque

queue = deque()
size, count = map(int, input().split())
for i in range(count):
    arrival, duration = map(int, input().split())
    while queue and queue[0] <= arrival:
        queue.popleft()
    if len(queue) < size:
        if queue:
            arrival = max(arrival, queue[-1])
        print(arrival)
        queue.append(arrival + duration)
    else:
        print(-1)

#1.Создаем дву направленный очередь (queue)
#2.По условию у нас указывается размер буфера (size) потом число пакетов (count)
#функция map принимает функцию int и затем итерабельную последовательность input() которое мы введем через пробел блогодаря функции split()
#size, count = map(int, input().split())  -> size, count = map(int, input(1 0).split()) числа 1 и 0 типа инт которое мы введем через пробел

#3.Далее count раз делаем цикл т.е. count - это количество пакетов, нам нужно обработать count пакетов

#4.Нам дано время прибытия это переменная (arrival) и время требуемая на его обработку это переменная (duration)
# здесь так же вводим числа типа int через пробел.

#5.На момент поступления пакета нужно проверить если arrival[0] - это самый 1ый элемент и она имеет значение <= чем время прибытия arrival
#(arrival[0] <= arrival) то все такие пакеты из очереди нужно убирать т.е. arrival = [0 1] duration [0 2] случае когда выход будет [0 -1]
#т.к по условию arrival[0] и arrival равны 0=0
#Пока queue и queue[0] <= arrival - времени прибытия,

#6. делаем след. из начала очереди убираем пакеты которые уже отработали

#7. если длина очереди < меньше чем размер которое по условию задачи дается (len(queue) < size)
# то нужно вывести время начала обработки пакета print(arrival)

#8.Например: 0 3  приходит пакет в момент времени 5 и начинает обрабатываться когда закончит свою обработку предыдуший элемент за 3 сек
#            5 2  и если время прибытия 5 < меньше 3 времени когда процесор освобождается

#9. то тогда время начала обновляем. время прибытия arrival это максимум между временем прибытия arrival и
# время когда освобождается последний поток queue[-1] -> max(arrival, queue[-1])

#10. Например: 0 3  пришел в момент времени arrival=1 и положится в буфер из за того. что процесор освободится в момент времени duration=3
#              1 2  наш максимум от последнего пакета перебьет время начала, по этому arrival перезаписали.

#11. если это не выполняется просто print(arrival)

#12. В очередь добовляется время когда процесор освобождается т.е. в очередь складываем время начала arrival + duration время выполнения

#13. иначе -1, когда нет место в буфере он будет отброшен.