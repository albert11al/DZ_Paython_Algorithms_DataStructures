#Учитывая бинарное дерево
#struct Node {       структура узла
  #int val;          внутр. значение;
  #Node *left;       Узел *слева;
  #Node *right;      узел *правый;
  #Node *next;       узел *следующий;
#}
#Заполните каждый следующий указатель, чтобы он указывал на его следующий правый узел.
#Если нет следующего правого узла, следующий указатель должен быть установлен в NULL
#Ввод: root(корень) = [1,2,3,4,5,ноль,7]
#Вывод:               [1,#,2,3,#,4,5,7,#]
#Объяснение: Учитывая вышеприведенное двоичное дерево (рисунок A), ваша функция должна заполнить каждый следующий указатель так,
#чтобы он указывал на его следующий правый узел, как на рисунке B. Сериализованный вывод находится в порядке уровней, связанном
#со следующими указателями, с '# ', означающий конец каждого уровня.

class Solution(object):
    def connect(self, root):

        if not root:
            return root
        level = 0
        q = [(root, level)]
        while q:
            cur, level = q.pop(0)
            if q:
                next_node, next_level = q[0]
                if next_level == level:
                    cur.next = next_node
            if cur.left:
                q.append((cur.left, level + 1))
            if cur.right:
                q.append((cur.right, level + 1))
        return root

#if not root: # если это пустое дере, т.е. нет корня
 #   return root # то тогда вернем этот пустой корень
#level = 0 # нам нужно отслеживать на каком уровне находится узел
# будем отслеживать эту информацию в очереди. приравниваем корневой уровень 0 (level = 0)
#q = [(root, level)] # будем хранить картеж с корнем и значением уровня
#while q: # и пока в очереди есть элементы , мы собераемся ее извлечь и напечатать ее, и затем
    #cur, level = q.pop(0) # извлекаем первый элемент, и еше мы будем получать не только элемент но и его уровень
    #if q: # если q все еше не пуст
      #  next_node, next_level = q[0] # то мы проверяем 1-ый элемент из очереди
     #   if next_level == level: # проверим равен ли след.уровень текушему уровню
    #        cur, next = next_node
   # if cur.left: #затем проверяем если у текушего узла левый узел
  #      q.append((cur.left, level + 1)) #еслие есть добовляет в очередь , изменяем в картеж по этому левый узел текушего узла должен иметь уровень на 1 больше чем текуший уровень
 #   if cur.right: #если у текушего узла правый узел
#        q.append(cur.right) #еслие есть добовляет в очередь