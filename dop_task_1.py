#Напишите функцию для удаления узла в односвязном списке.
#Вам не будет предоставлен доступ к началу списка,
# вместо этого вам будет предоставлен доступ к удаляемому узлу напрямую.
#Гарантируется, что удаляемый узел не является хвостовым узлом в списке.

#Ввод: голова = [4,5,1,9], узел = 5
#Выход: [4,1,9]
#Объяснение: вам дан второй узел со значением 5,
# связанный список должен стать 4 -> 1 -> 9 после вызова вашей функции.

#Ввод: голова = [4,5,1,9], узел = 1
#Выход: [4,5,9]
#Объяснение: вам дан третий узел со значением 1,
# связанный список должен стать 4 -> 5 -> 9 после вызова вашей функции.

# чтобы удалить 5 нужно сделать так, чтобы 4 указывал на 1, и т.к. это простой список одиночных сылок,
# а в простых списках одиночных сылок, когда находимся в текушем узле т.е. на 5 мы не можем вернуться назад к 4
# и таким образом мы скопируем 1 на место 5 т.е. станет [4,1,1,9] и затем удалим 1 под индексом 2
# этот метод не сработает если попросят удалить крайный элемент хвост

class Solution(object):
    def deleteNode(self, node):

        node.val = node.next.val    # переписываем 1 на место 5 (5=1) т.е node = 5 node.next = 1. станет [4,1,1,9], val- копировать
        node.next = node.next.next  # теперь удаляем 1 по индексу 2.
                                    # для это нужно связать сылку 1 по индексу 1, с 9 по индексу 3.
                                    # node.next = 1 node.next.next = 9 сейчас связать сылку 1 по индексу 2 = 9 по индексу 3. это значит, что сылка 1 по индексу 1 смотрит на 9 по индексу 3

# чтобы удалить 1 нужно сделать так, чтобы 5 сылался на 9
# для этого node = node.next т.е. node = 1 node.next =9/ таким образом 5 сылается на 9 обходя 1
class Solution(object):
    def deleteNode(self, node):

        node = node.next

