#Учитывая целочисленный массив nums, отсортированный в неубывающем порядке,
#удалите дубликаты на месте, чтобы каждый уникальный элемент появлялся только один раз.
#Относительный порядок элементов должен быть сохранен.

#Поскольку в некоторых языках невозможно изменить длину массива,
#вместо этого вы должны поместить результат в первую часть массива nums.
#Более формально, если есть k элементов после удаления дубликатов,
#то первые k элементов nums должны содержать окончательный результат. Неважно,
#что вы оставляете за первыми k элементами.

#Например:
#Ввод: числа = [0,0,1,1,1,2,2,3,3,4]
#Выход: 5, числа = [0,1,2,3,4,_,_,_,_,_]
#Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов
#nums равны 0, 1, 2, 3 и 4 соответственно.
#Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).
import unittest
def delete_copy(app: list[int]) -> list:
    result = []
    for i in app:
        if i not in result:
            result.append(i)
    print('k =', len(result), result)
    return result

class TestDeleteCopy(unittest.TestCase):
    def test_delete(self):
        self.assertEqual([2, 3, 5, 4, 6], delete_copy([2, 3, 3, 2, 5, 4, 4, 6]))
        self.assertEqual([2], delete_copy([2, 2, 2, 2, 2]))
        self.assertEqual([2, 3, 5], delete_copy([2, 3, 3, 2, 5]))
        self.assertEqual([5, 4, 1, 2], delete_copy([5, 5, 4, 4, 1, 2]))